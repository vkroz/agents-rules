"""CLI entry point for agentpack."""

import shutil
from pathlib import Path
from typing import Optional

import typer
import yaml

from agent_pack import __version__

app = typer.Typer(help="AI agent configuration manager.")

AGENTPACK_DIR = ".agentpack"
MARKER_PREFIX = "GENERATED BY agentpack."

DEFAULT_CONFIG = """\
agents: [claude, cursor]
gitignore: true
"""

DEFAULT_CLAUDE_MD = """\
---
description: Main project instructions for AI agents
alwaysApply: true
---

# Project Instructions

<!-- Add your project-specific instructions here.
     This file maps to CLAUDE.md (when claude agent is configured)
     or AGENTS.md (when cursor-only) at the project root,
     when you run `agentpack generate`. -->
"""


def version_callback(value: bool):
    if value:
        print(f"agentpack {__version__}")
        raise typer.Exit()


@app.callback(invoke_without_command=True)
def main(
    ctx: typer.Context,
    version: Optional[bool] = typer.Option(
        None,
        "--version",
        callback=version_callback,
        is_eager=True,
        help="Show version and exit.",
    ),
):
    """AI agent configuration manager."""
    if ctx.invoked_subcommand is None:
        print(ctx.get_help())


@app.command()
def init(
    path: Optional[Path] = typer.Argument(
        None,
        help="Target directory. Defaults to current directory.",
    ),
):
    """Bootstrap .agentpack/ directory structure with starter config."""
    root = (path or Path.cwd()).resolve()
    ap_dir = root / AGENTPACK_DIR

    if ap_dir.exists():
        typer.echo(f"Already initialized: {ap_dir}", err=True)
        raise typer.Exit(code=1)

    rules_dir = ap_dir / "rules"
    skills_dir = ap_dir / "skills"

    rules_dir.mkdir(parents=True)
    skills_dir.mkdir(parents=True)

    (ap_dir / "agentpack.yaml").write_text(DEFAULT_CONFIG)
    (rules_dir / "CLAUDE.md").write_text(DEFAULT_CLAUDE_MD)

    typer.echo(f"Initialized {ap_dir}")
    typer.echo("  agentpack.yaml   — project configuration")
    typer.echo("  rules/CLAUDE.md  — starter project instructions")
    typer.echo("\nNext: edit your rules, then run `agentpack generate`.")


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _load_config(ap_dir: Path) -> dict:
    config_path = ap_dir / "agentpack.yaml"
    if not config_path.exists():
        typer.echo(f"Config not found: {config_path}", err=True)
        raise typer.Exit(code=1)
    with open(config_path) as f:
        return yaml.safe_load(f) or {}


def _find_skill_md(skill_dir: Path) -> Optional[Path]:
    """Return the skill markdown file in a skill directory (case-insensitive match for skill.md)."""
    for f in skill_dir.iterdir():
        if f.is_file() and f.name.lower() == "skill.md":
            return f
    return None


def _has_marker(content: str) -> bool:
    return MARKER_PREFIX in content


def _strip_frontmatter(content: str) -> str:
    """Remove YAML frontmatter block from markdown content."""
    if not content.startswith("---"):
        return content
    end_idx = content.find("\n---", 3)
    if end_idx == -1:
        return content
    after = end_idx + 4
    if after < len(content) and content[after] == "\n":
        after += 1
    return content[after:]


def _add_yaml_marker(content: str, source_rel: str) -> str:
    """Insert YAML comment marker after the opening ``---`` in frontmatter."""
    marker_line = f"# {MARKER_PREFIX} Source: {source_rel}"
    if content.startswith("---\n"):
        return f"---\n{marker_line}\n{content[4:]}"
    return f"---\n{marker_line}\n---\n{content}"


def _add_html_marker(content: str, source_rel: str) -> str:
    """Prepend HTML comment marker."""
    return f"<!-- {MARKER_PREFIX} Source: {source_rel} -->\n{content}"


def _write_generated(out: Path, content: str, force: bool, root: Path) -> bool:
    """Write a generated file with overwrite protection. Returns True if written."""
    if out.exists():
        existing = out.read_text()
        if not _has_marker(existing) and not force:
            rel = out.relative_to(root)
            typer.echo(
                f"WARN: {rel} already exists and was not generated by agentpack, skipping. "
                "Use --force to overwrite.",
                err=True,
            )
            return False
    out.parent.mkdir(parents=True, exist_ok=True)
    out.write_text(content)
    return True


def _copy_supplementary(skill_src: Path, skill_out: Path) -> None:
    """Copy supplementary directories (scripts/, references/, assets/, etc.) alongside SKILL.md."""
    for child in skill_src.iterdir():
        if child.is_dir():
            dest = skill_out / child.name
            if dest.exists():
                shutil.rmtree(dest)
            shutil.copytree(child, dest)


def _cleanup_stale_generated(root: Path, agents: list) -> None:
    """Delete agentpack-generated files before regenerating to remove stale artifacts."""
    # Always clean up root-level generated files regardless of current agent config,
    # so that switching agents (e.g. removing claude) removes stale CLAUDE.md.
    for filename in ("CLAUDE.md", "AGENTS.md"):
        f = root / filename
        if f.exists():
            try:
                content = f.read_text(encoding="utf-8", errors="ignore")
                if _has_marker(content):
                    f.unlink()
            except OSError:
                pass

    dirs_to_scan = []
    if "claude" in agents:
        dirs_to_scan.append(root / ".claude")
    if "cursor" in agents:
        dirs_to_scan.append(root / ".cursor" / "rules")
        dirs_to_scan.append(root / ".cursor" / "skills")

    for scan_dir in dirs_to_scan:
        if not scan_dir.exists():
            continue
        for f in scan_dir.rglob("*"):
            if f.is_file():
                try:
                    content = f.read_text(encoding="utf-8", errors="ignore")
                    if _has_marker(content):
                        f.unlink()
                except OSError:
                    pass


# ---------------------------------------------------------------------------
# Generators
# ---------------------------------------------------------------------------


def _generate_claude(root: Path, ap_dir: Path, force: bool) -> None:
    rules_dir = ap_dir / "rules"
    skills_dir = ap_dir / "skills"

    agents_md = rules_dir / "CLAUDE.md"
    if agents_md.exists():
        out = root / "CLAUDE.md"
        content = _strip_frontmatter(agents_md.read_text())
        content = _add_html_marker(content, ".agentpack/rules/CLAUDE.md")
        if _write_generated(out, content, force, root):
            typer.echo(f"  {out.relative_to(root)}")

    for rule_file in sorted(rules_dir.glob("*.md")):
        if rule_file.name == "CLAUDE.md":
            continue
        out = root / ".claude" / "rules" / rule_file.name
        content = _add_yaml_marker(
            rule_file.read_text(), f".agentpack/rules/{rule_file.name}"
        )
        if _write_generated(out, content, force, root):
            typer.echo(f"  {out.relative_to(root)}")

    if skills_dir.exists():
        for skill_dir in sorted(d for d in skills_dir.iterdir() if d.is_dir()):
            skill_md = _find_skill_md(skill_dir)
            if skill_md:
                out = root / ".claude" / "skills" / skill_dir.name / "SKILL.md"
                content = _add_yaml_marker(
                    skill_md.read_text(),
                    f".agentpack/skills/{skill_dir.name}/SKILL.md",
                )
                if _write_generated(out, content, force, root):
                    typer.echo(f"  {out.relative_to(root)}")
                _copy_supplementary(skill_dir, out.parent)


def _generate_cursor(root: Path, ap_dir: Path, agents: list, force: bool) -> None:
    rules_dir = ap_dir / "rules"
    skills_dir = ap_dir / "skills"

    # When cursor-only: generate AGENTS.md at project root (stripped of frontmatter).
    # When claude is also present, CLAUDE.md at root is recognised by Cursor natively.
    if "claude" not in agents:
        agents_md = rules_dir / "CLAUDE.md"
        if agents_md.exists():
            out = root / "AGENTS.md"
            content = _strip_frontmatter(agents_md.read_text())
            content = _add_html_marker(content, ".agentpack/rules/CLAUDE.md")
            if _write_generated(out, content, force, root):
                typer.echo(f"  {out.relative_to(root)}")

    # Modular rules — CLAUDE.md is handled above, never goes into .cursor/rules/
    for rule_file in sorted(rules_dir.glob("*.md")):
        if rule_file.name == "CLAUDE.md":
            continue
        out = root / ".cursor" / "rules" / rule_file.name
        content = _add_yaml_marker(
            rule_file.read_text(), f".agentpack/rules/{rule_file.name}"
        )
        if _write_generated(out, content, force, root):
            typer.echo(f"  {out.relative_to(root)}")

    if "claude" not in agents and skills_dir.exists():
        for skill_dir in sorted(d for d in skills_dir.iterdir() if d.is_dir()):
            skill_md = _find_skill_md(skill_dir)
            if skill_md:
                out = root / ".cursor" / "skills" / skill_dir.name / "SKILL.md"
                content = _add_yaml_marker(
                    skill_md.read_text(),
                    f".agentpack/skills/{skill_dir.name}/SKILL.md",
                )
                if _write_generated(out, content, force, root):
                    typer.echo(f"  {out.relative_to(root)}")
                _copy_supplementary(skill_dir, out.parent)


def _update_gitignore(root: Path, agents: list) -> None:
    gitignore = root / ".gitignore"
    entries = []
    if "claude" in agents:
        entries.append("CLAUDE.md")
        entries.append(".claude/")
    if "cursor" in agents:
        entries.append(".cursor/")
    if "cursor" in agents and "claude" not in agents:
        entries.append("AGENTS.md")

    existing = gitignore.read_text() if gitignore.exists() else ""
    lines = existing.splitlines()

    added = []
    for entry in entries:
        if entry not in lines:
            lines.append(entry)
            added.append(entry)

    if added:
        gitignore.write_text("\n".join(lines) + "\n")
        for e in added:
            typer.echo(f"  .gitignore: added {e}")


# ---------------------------------------------------------------------------
# Commands
# ---------------------------------------------------------------------------


@app.command()
def generate(
    path: Optional[Path] = typer.Argument(
        None,
        help="Target directory. Defaults to current directory.",
    ),
    force: bool = typer.Option(
        False,
        "--force",
        help="Overwrite files modified outside agentpack.",
    ),
):
    """Compile canonical rulesets into tool-specific configs."""
    root = (path or Path.cwd()).resolve()
    ap_dir = root / AGENTPACK_DIR

    if not ap_dir.exists():
        typer.echo("Not initialized. Run `agentpack init` first.", err=True)
        raise typer.Exit(code=1)

    config = _load_config(ap_dir)
    agents = config.get("agents", [])
    use_gitignore = config.get("gitignore", True)

    if not agents:
        typer.echo("No agents configured in agentpack.yaml", err=True)
        raise typer.Exit(code=1)

    typer.echo("Generating...")
    _cleanup_stale_generated(root, agents)

    if "claude" in agents:
        typer.echo("Claude:")
        _generate_claude(root, ap_dir, force)

    if "cursor" in agents:
        typer.echo("Cursor:")
        _generate_cursor(root, ap_dir, agents, force)

    if use_gitignore:
        _update_gitignore(root, agents)

    typer.echo("Done.")


@app.command()
def sync(
    remote: Optional[str] = typer.Argument(None, help="Remote repository URL."),
):
    """Pull shared configurations from a remote repository."""
    print("agentpack sync: not yet implemented")
